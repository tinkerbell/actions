package artifacthub

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"time"

	"github.com/mattn/godown"
	"github.com/pkg/errors"
	"github.com/yuin/goldmark"
	meta "github.com/yuin/goldmark-meta"
	"github.com/yuin/goldmark/parser"
	"gopkg.in/yaml.v3"
)

// Manifest represents the ArtifactHub manifest file that gets used to populate
// the website.
type Manifest struct {
	Version          string `yaml:"version"`
	Name             string `yaml:"name"`
	DisplayName      string `yaml:"displayName"`
	CreatedAt        string `yaml:"createdAt"`
	Description      string `yaml:"description"`
	LogoPath         string `yaml:"logoPath"`
	Digest           string `yaml:"digest,omitempty"`
	License          string `yaml:"license,omitempty"`
	HomeURL          string `yaml:"homeURL,omitempty"`
	AppVersion       string `yaml:"appVersion,omitempty"`
	ContainersImages []struct {
		Name  string `yaml:"name,omitempty"`
		Image string `yaml:"image,omitempty"`
		// Whitelisted string `yaml:"whitelisted,omitempty"`
	} `yaml:"containersImages,omitempty"`
	// ContainsSecurityUpdates string   `yaml:"containsSecurityUpdates,omitempty"`
	// Operator                string   `yaml:"operator,omitempty"`
	// Deprecated              string   `yaml:"deprecated,omitempty"`
	// Prerelease              string   `yaml:"prerelease,omitempty"`
	Keywords []string `yaml:"keywords,omitempty"`
	Links    []struct {
		Name string `yaml:"name"`
		URL  string `yaml:"url"`
	} `yaml:"links,omitempty"`
	Readme string `yaml:"readme,omitempty"`
	// Install     string   `yaml:"install,omitempty"`
	// Changes     []string `yaml:"changes,omitempty"`
	// Maintainers []struct {
	// Name  string `yaml:"name"`
	// Email string `yaml:"email"`
	// } `yaml:"maintainers,omitempty"`
	Provider struct {
		Name string `yaml:"name"`
	} `yaml:"provider"`
	// Ignore []string `yaml:"ignore"`
}

func PopulateFromActionMarkdown(file io.Reader, m *Manifest) error {
	md := goldmark.New(
		goldmark.WithExtensions(
			meta.Meta,
		),
	)
	readme, err := ioutil.ReadAll(file)
	if err != nil {
		return errors.Wrap(err, "error reading the README.md")
	}
	var buf bytes.Buffer
	context := parser.NewContext()
	if err := md.Convert(readme, &buf, parser.WithContext(context)); err != nil {
		return errors.Wrap(err, "error converting the README.md")
	}
	metaData := meta.Get(context)

	// This is a very dirty hack but since I am not able to understand how to
	// get the original body of the README.md (without the headers). A quick
	// way I have to get markdown and not YAML is to re-convert it.
	// https://github.com/yuin/goldmark/discussions/168#discussioncomment-219417
	readmeBack := bytes.NewBuffer([]byte{})
	if err := godown.Convert(readmeBack, &buf, nil); err != nil {
		return errors.Wrap(err, "error converting the readme back from html to markdown")
	}

	mustString := func(name string, i interface{}) string {
		s, ok := i.(string)
		if !ok {
			panic(name + " is not a string!")
		}
		return s
	}
	m.Name = mustString("slug", metaData["slug"])
	m.DisplayName = mustString("name", metaData["name"])
	m.Readme = readmeBack.String()
	m.Version = mustString("version", metaData["version"])[1:]
	m.AppVersion = m.Version
	m.Keywords = strings.Split(mustString("tags", metaData["tags"]), ",")
	m.Description = mustString("description", metaData["description"])

	m.ContainersImages = []struct {
		Name  string `yaml:"name,omitempty"`
		Image string `yaml:"image,omitempty"`
		// Whitelisted string `yaml:"whitelisted,omitempty"`
	}{
		{
			Name:  m.Name,
			Image: fmt.Sprintf("quay.io/tinkerbell-actions/%s:v%s", m.Name, m.Version),
		},
	}

	if _, err := time.Parse(time.RFC3339, metaData["createdAt"].(string)); err != nil {
		println(fmt.Sprintf("action: %s error converting createdAt right format is \"2016-06-20T12:41:45.14Z\" got %s", m.Name, metaData["createdAt"].(string)))
	} else {
		m.CreatedAt = mustString("createdAt", metaData["createdAt"])
	}

	return nil
}

var commentHeader = []byte("# this file is generated by ./cmd/gen/main.go\n")

func WriteToFile(manifest *Manifest, dst string) error {
	b, err := yaml.Marshal(manifest)
	if err != nil {
		return errors.Wrap(err, "error marshalling manifest to yaml")
	}
	if err := os.MkdirAll(path.Join(dst, manifest.Name, manifest.Version), 0o700); err != nil {
		return errors.Wrap(err, "error creating directory")
	}
	dstFile, err := os.OpenFile(
		path.Join(dst, manifest.Name, manifest.Version, "artifacthub-pkg.yml"),
		os.O_CREATE|os.O_WRONLY,
		0o644)
	if err != nil {
		return errors.Wrap(err, "error creating manifest file")
	}
	_, err = dstFile.Write(append(commentHeader, b...))
	if err != nil {
		return errors.Wrap(err, "error writing manifest to file")
	}
	return nil
}
